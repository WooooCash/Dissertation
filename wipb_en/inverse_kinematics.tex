\chapter{Inverse Kinematics in the Unity Engine} 
The demo application written for the purpose of this dissertation includes two
separate use cases of skeletal animation using inverse kinematics in the Unity
engine. The first example is that of a four legged spider which uses the
technique as a means to more naturally adjust its limbs to the terrain it moves
around upon. The second example is the application of inverse kinematics to an
animation sequence of a human character pressing multiple buttons in succession.
The use of inverse kinematics allows the character to adjust its animation to hit
all the buttons without the need for a baked animation targeted towards each
button, as well as dynamically adjust the order of the buttons to be hit.

Although there are two separate use cases demonstrated in this application, both
use the same implementation of the FABRIK algorithm. 


\section{FABRIK implementation}
This implementation of the FABRIK algorithm is based on the paper written by the
author of the Unity engine FABRIK implementation. (CITE THE PAPER LMAO). For the
purposes of this application, the basic algorithm is implemented without many
additional constraints and options available. The one constraint added on to
this implementation is that of pole targets which will be further explained when
discussing the code behind them.

The script which implements the algorithm in this project takes in a few
parameters required to set up the mechanism. First and foremost, the root and
leaf nodes must be provided in order to define the kinematic chain which is to
be manipulated. The next object which the script must have knowledge of is the
target transform which the end effector will attempt to move to. All the
aforementioned parameters are required for the script to function. Additionally,
a pole target object may be optionally passed in if the use case requires it to
function in a manner that is desired.

\textit{Maybe throw in a snippet of the script which takes in parameters}

The first case which the algorithm must cover is if the distance from the root
to the target object is greater than the sum of distances between each adjacent
bone in the defined kinematic chain. In this case, the target is out of reach. Given
that the bones in a skeleton are expected to keep a fixed length, the end
effector will not be able to reach the target, and instead the kinematic chain
straightens and extends in the direction of the target. There is no need to
continue with the iterative portion of the algorithm.

In the implementation below, square magnitudes are used to
avoid the calculation of square roots, thus slightly optimizing the initial
check.

\textit{Show code}

The scenario where the target is within the reach of the kinematic chain
utilizes iterative forward and backward component after which the algorithm is
named. Before each iteration, the positions of the joint transforms are copied.
All operations and calculations are performed on these copied transforms and at
the end of the full pass, the new positions are then copied back to the
kinematic chain. \textbf{CHECK IF THE ALGORITHM WORKS WITHOUT THIS. MIGHT SAVE
SOME MEMORY LMAO}. It is also important to note that the modification of the
transforms is done in Unity's \textit{LateUpdate} function. When using a mix of
inverse kinematics and baked animation, the object to which the IK script is
attached will have Unity's built-in \textit{Animator} component. If the IK
script updates joint transforms in the \textit{Update} method, then they may be
overwritten by the \textit{Animator} component. 

The forward pass of the algorithm iterates through the chain starting from the
end effector and ending at the root. At the start, the end effector's position
is set to be equal to the position of the target. A straight line is then drawn
from the end effector to the following node. This neighbours position is then
interpolated along the line so that the original distance between the two nodes
is kept. The same operation is performed for each pair of neighbouring nodes
throughout the pass. 

\textit{show code}

When the forward pass is complete, the root node is displaced from its original
position. This is undesired, as the root's node position should not be affected
by the algorithm. To remedy this, the next step is to repeat the forwards pass,
but this time in reverse. The root node's position is set equal to what it was
at the beginning of the frame. The next node is then interpolated between its
current position and the root to keep the initial bone length. As with the
forward pass, this is repeated for each subsequent pair of nodes. 

\textit{show code}

These two steps are repeated together until the end effector is within
a threshold distance of the target. The FABRIK algorithm is a heuristic
algorithm, and as such is does not lead to an exact result. Instead, it aims to
approximate the correct solution and solves the problem in a less complex and
more optimized way. Again, the square distances are used to avoid the
calculation of square roots. 

\textit{show code}

\textbf{POLE TARGETS. FIND A SOURCE WHICH EXPLAINS THE METHOD USED IN MY
PROGRAM. IF NOT THEN REFER TO THE YOUTUBE VIDEO LOLOL}


\section{Spider Movement}
The first use case for inverse kinematics in the demo application is that of
a four legged spider. The algorithm is used to adjust the creature's limbs to
uneven terrain, leading to a much more natural and realistic movement.
\subsection{Project Setup}
Each one of the spiders legs is treated as a separate kinematic chain. The
spider prefab consists of a container which holds the spider object itself, set
of empty objects to which the four IK scripts are attached for the purpose of
easy yet separated access. The prefab also contains sets of ray casts and
targets.
\subsubsection{hihihi}


\subsection{Scripts}
\section{Human Animation Sequence}
\subsection{Project Setup}
\subsection{Scripts}
